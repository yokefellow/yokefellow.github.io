(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{495:function(t,e,r){"use strict";r.r(e);var a=r(2),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("This is A-1-1")]),t._v(" "),r("h2",{attrs:{id:"一-二级标题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一-二级标题"}},[t._v("#")]),t._v(" 一（二级标题）")]),t._v(" "),r("blockquote",[r("p",[t._v("SOA 架构（Service-Oriented Architecture）")])]),t._v(" "),r("blockquote",[r("p",[t._v("面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式。")])]),t._v(" "),r("h3",{attrs:{id:"_1-1-三级标题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-三级标题"}},[t._v("#")]),t._v(" 1.1（三级标题）")]),t._v(" "),r("p",[t._v("烟囱式架构（Information Silo Architecture）：信息烟囱又名信息孤岛（Information Island），使用这种架构的系统也被称为孤岛式信息系统或者烟囱式信息系统。它指的是一种完全不与其他相关信息系统进行互操作或者协调工作的设计模式。这样的系统其实并没有什么“架构设计”可言。接着上一节中企业与部门的例子来说，如果两个部门真的完全不会发生任何交互，就并没有什么理由强迫它们必须在一栋楼里办公；两个不发生交互的信息系统，让它们使用独立的数据库和服务器即可实现拆分，而唯一的问题，也是致命的问题是，企业中真的存在完全不发生交互的部门吗？对于两个信息系统来说，哪怕真的毫无业务往来关系，但系统的人员、组织、权限等主数据，会是完全独立、没有任何重叠的吗？这样“独立拆分”“老死不相往来”的系统，显然不可能是企业所希望见到的。")]),t._v(" "),r("h3",{attrs:{id:"_1-2-三级标题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-三级标题"}},[t._v("#")]),t._v(" 1.2（三级标题）")]),t._v(" "),r("p",[t._v("微内核架构（Microkernel Architecture）：微内核架构也被称为插件式架构（Plug-in Architecture）。既然在烟囱式架构中，没有业务往来关系的系统也可能需要共享人员、组织、权限等一些的公共的主数据，那不妨就将这些主数据，连同其他可能被各子系统使用到的公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心（Kernel，也称为 Core System），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样也可提供可扩展的、灵活的、天然隔离的功能特性，即微内核架构，如图 1-2 所示。\n这种模式很适合桌面应用程序，也经常在 Web 应用程序中使用。任何计算机系统都是由各种软件互相配合工作来实现具体功能的，本节列举的不同架构实现的软件，都可视作整个系统的某种插件。对于平台型应用来说，如果我们希望将新特性或者新功能及时加入系统，微内核架构会是一种不错的方案。微内核架构也可以嵌入到其他的架构模式之中，通过插件的方式来提供新功能的定制开发能力，如果你准备实现一个能够支持二次开发的软件系统，微内核也会是一种良好的选择。\n不过，微内核架构也有它的局限和使用前提，它假设系统中各个插件模块之间是互不认识，不可预知系统将安装哪些模块，因此这些插件可以访问内核中一些公共的资源，但不会直接交互。可是，无论是企业信息系统还是互联网应用，这一前提假设在许多场景中都并不成立，我们必须找到办法，既能拆分出独立的系统，也能让拆分后的子系统之间顺畅地互相调用通信。")]),t._v(" "),r("h3",{attrs:{id:"_1-3-三级标题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-三级标题"}},[t._v("#")]),t._v(" 1.3（三级标题）")]),t._v(" "),r("p",[t._v("事件驱动架构（Event-Driven Architecture）：为了能让子系统互相通信，一种可行的方案是在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去，如此，每一个消息的处理者都是独立的，高度解耦的，但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动，如图 1-3 所示。")]),t._v(" "),r("h2",{attrs:{id:"二-二级标题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二-二级标题"}},[t._v("#")]),t._v(" 二（二级标题）")]),t._v(" "),r("blockquote",[r("p",[t._v("微服务架构（Microservices）")])]),t._v(" "),r("blockquote",[r("p",[t._v("微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。")])]),t._v(" "),r("h2",{attrs:{id:"_2-1-三级标题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-三级标题"}},[t._v("#")]),t._v(" 2.1（三级标题）")]),t._v(" "),r("h2",{attrs:{id:"_2-2-三级标题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-三级标题"}},[t._v("#")]),t._v(" 2.2（三级标题）")]),t._v(" "),r("h2",{attrs:{id:"_2-3-三级标题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-三级标题"}},[t._v("#")]),t._v(" 2.3（三级标题）")])])}),[],!1,null,null,null);e.default=s.exports}}]);